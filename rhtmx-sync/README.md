# rhtmx-sync

Automatic IndexedDB synchronization for RHTMX applications with **minimal developer code**.

## Features

- ✅ **Zero-config sync**: Add one derive macro, get automatic sync
- ✅ **Offline support**: Mutations queue when offline, sync when online
- ✅ **Real-time updates**: SSE pushes changes to all connected clients
- ✅ **Conflict resolution**: Last-write-wins, client-wins, server-wins strategies
- ✅ **Type-safe**: Rust's type system ensures correctness
- ✅ **Lightweight client**: ~12 KB JavaScript (no external dependencies)
- ✅ **Works with existing code**: No changes to your HTMX templates

## Quick Start

### 1. Add to your project

```toml
[dependencies]
rhtmx-sync = { path = "../rhtmx-sync" }
```

### 2. Add `#[derive(Syncable)]` to your models

```rust
use rhtmx_sync::Syncable;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow, Syncable)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}
```

### 3. Initialize SyncEngine in main.rs

```rust
use rhtmx_sync::{SyncEngine, SyncConfig};

#[tokio::main]
async fn main() {
    let db_pool = init_db("sqlite://app.db").await?;

    // Create sync engine
    let sync_engine = SyncEngine::new(SyncConfig::new(
        db_pool.clone(),
        vec!["users".to_string()],  // Entities to sync
    )).await?;

    // Add routes to your app
    let app = Router::new()
        .merge(your_routes())
        .merge(sync_engine.routes());  // Adds /api/sync/*

    axum::serve(listener, app).await?;
}
```

### 4. Add script tag to your HTML layout

```html
<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <!-- Add rhtmx-sync script -->
    <script src="/api/sync/client.js"
            data-sync-entities="users"
            data-debug="true">
    </script>
</head>
<body>
    <!-- Your normal HTMX code -->
    <div id="users"
         hx-get="/api/users"
         hx-trigger="load, rhtmx:users:changed from:body">
        <!-- User list -->
    </div>
</body>
</html>
```

### 5. That's it! ✨

Your app now has:
- Automatic IndexedDB caching
- Real-time updates via SSE
- Offline support with mutation queueing
- Conflict resolution

## How It Works

```
┌─────────────────┐      SSE Stream       ┌──────────────────┐
│  SQLite (Server)│ ───────────────────► │ IndexedDB (Client)│
│                 │                       │                   │
│  1. DB changes  │   JSON over HTTP      │  3. Cache updated │
│  2. Log tracked │ ◄──────────────────── │  4. UI refreshed  │
└─────────────────┘   Offline mutations   └──────────────────┘
```

1. **Server detects changes**: `#[derive(Syncable)]` auto-tracks all DB mutations
2. **SSE broadcasts**: Real-time updates sent to all connected clients
3. **IndexedDB syncs**: Client library updates local cache
4. **UI refreshes**: HTMX triggers update affected elements
5. **Offline mutations**: Queue locally, sync when reconnected

## API Reference

### Server-Side

#### `#[derive(Syncable)]`

```rust
#[derive(Syncable)]
#[sync(
    table = "users",                    // Optional: table name
    strategy = SyncStrategy::LastWriteWins,  // Conflict resolution
)]
pub struct User {
    pub id: i32,
    pub name: String,
}
```

#### `SyncEngine`

```rust
let engine = SyncEngine::new(SyncConfig {
    db_pool: pool.clone(),
    entities: vec!["users", "posts"],
    strategy: SyncStrategy::LastWriteWins,
    debug: true,
}).await?;

// Get routes
let routes = engine.routes();

// Manual cleanup
engine.cleanup(7).await?;  // Clean up logs older than 7 days
```

### Client-Side

#### Script Tag Configuration

```html
<script src="/api/sync/client.js"
        data-sync-entities="users,posts,comments"
        data-conflict-strategy="last-write-wins"
        data-debug="true">
</script>
```

#### JavaScript API

```javascript
// Access the sync instance
window.rhtmxSync.syncEntity('users');  // Manual sync
window.rhtmxSync.log('message');       // Debug logging

// Listen for events
document.addEventListener('rhtmx:sync:ready', () => {
    console.log('Sync initialized');
});

document.addEventListener('rhtmx:users:changed', (e) => {
    console.log('User changed:', e.detail.id);
});
```

## HTTP Endpoints

Auto-generated by `SyncEngine`:

### `GET /api/sync/:entity?since=:version`

Get changes since a specific version.

**Response:**
```json
{
    "entity": "users",
    "version": 42,
    "changes": [
        {
            "id": 1,
            "action": "update",
            "data": { "id": 1, "name": "Alice" },
            "version": 42
        }
    ]
}
```

### `POST /api/sync/:entity`

Push client changes to server.

**Request:**
```json
{
    "changes": [
        {
            "id": "1",
            "action": "create",
            "data": { "name": "Bob" }
        }
    ]
}
```

### `GET /api/sync/events` (SSE)

Real-time event stream.

### `GET /api/sync/client.js`

Serves the JavaScript client library.

## Conflict Resolution

### Strategies

```rust
pub enum SyncStrategy {
    LastWriteWins,   // Default: newest timestamp wins
    ClientWins,      // Client changes always win
    ServerWins,      // Server changes always win
}
```

### Custom Resolvers

```rust
impl ConflictResolver<Document> for MyResolver {
    fn resolve(&self, server: Document, client: Document) -> Document {
        // Your custom merge logic
        merge_documents(server, client)
    }
}
```

## Examples

See `examples/todo_sync.rs` for a complete working example.

Run with:
```bash
cargo run --example todo_sync
```

## Bundle Size

- Client JavaScript: ~12 KB gzipped
- No external dependencies
- Works with all modern browsers

## Browser Compatibility

- Chrome/Edge: ✅
- Firefox: ✅
- Safari: ✅
- Opera: ✅

Requires:
- IndexedDB support
- EventSource (SSE) support
- ES6+ JavaScript

## Performance

- Incremental sync (not full table dumps)
- Connection pooling for database
- Broadcast for SSE (minimal memory)
- Automatic cleanup of old sync logs

## Limitations

- SQLite only (PostgreSQL support planned)
- Simple conflict resolution (CRDTs planned)
- 50MB IndexedDB quota (browser default)

## Roadmap

- [ ] PostgreSQL support (LISTEN/NOTIFY)
- [ ] CRDT integration (Automerge)
- [ ] Field-level sync (not just entity-level)
- [ ] WebSocket option (alternative to SSE)
- [ ] Multi-tab sync (BroadcastChannel)
- [ ] Compression for large payloads
- [ ] Batch sync optimization

## License

MIT

## Contributing

Contributions welcome! Please open an issue first to discuss changes.
