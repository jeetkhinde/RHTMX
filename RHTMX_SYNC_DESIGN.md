# rhtmx-sync Crate Design

## Overview
`rhtmx-sync` is a crate that provides automatic IndexedDB synchronization for RHTMX applications with minimal developer code.

## Crate Structure

```
rhtmx-sync/
├── Cargo.toml
├── src/
│   ├── lib.rs              # Main sync engine
│   ├── syncable.rs         # Syncable trait definition
│   ├── change_tracker.rs   # Database change tracking
│   ├── sse.rs              # Server-Sent Events handler
│   ├── sync_api.rs         # /api/sync endpoints
│   ├── conflict.rs         # Conflict resolution strategies
│   └── js/
│       └── rhtmx-sync.js   # Client-side JavaScript (embedded)
├── rhtmx-sync-macro/       # Proc macro crate
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs          # #[derive(Syncable)] implementation
└── examples/
    └── todo_sync.rs        # Example app with sync
```

## API Design

### 1. Server-Side: Derive Macro

```rust
use rhtmx_sync::{Syncable, SyncStrategy};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow, Syncable)]
#[sync(
    table = "users",                    // Optional: defaults to struct name
    strategy = SyncStrategy::LastWriteWins,  // Default conflict resolution
    offline_writes = true,              // Allow offline mutations
)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub age: i32,

    // Auto-generated by macro (hidden from user):
    #[sync(skip)]
    pub _version: Option<i64>,          // Optimistic concurrency control
    #[sync(skip)]
    pub _modified_at: Option<DateTime<Utc>>,
}
```

### 2. Server-Side: Sync Engine Setup

```rust
use rhtmx_sync::{SyncEngine, SyncConfig};
use axum::Router;

#[tokio::main]
async fn main() {
    let db_pool = init_db("sqlite://app.db").await?;

    // Initialize sync engine (one-liner!)
    let sync_engine = SyncEngine::new(SyncConfig {
        db_pool: db_pool.clone(),
        entities: vec!["users", "posts", "comments"],
    }).await?;

    // Add sync routes to your app (automatic!)
    let app = Router::new()
        .merge(your_existing_routes())
        .merge(sync_engine.routes());  // Adds /api/sync/*, /api/sync/events

    // Start server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
}
```

### 3. Client-Side: HTML Setup

```html
<!DOCTYPE html>
<html>
<head>
    <!-- Add the sync script with configuration -->
    <script src="/api/sync/client.js"
            data-sync-entities="users,posts,comments"
            data-conflict-strategy="last-write-wins"
            data-debug="true">
    </script>
</head>
<body>
    <!-- Normal HTMX code - works exactly the same! -->
    <div id="users"
         hx-get="/api/users"
         hx-trigger="load, rhtmx:users:changed from:body">
        <!-- User list rendered by server -->
    </div>

    <form hx-post="/api/users" hx-target="#users">
        <!-- This will work offline and sync when online! -->
        <input name="name" required>
        <button type="submit">Add User</button>
    </form>
</body>
</html>
```

## Implementation Details

### 1. Change Tracking Table

Auto-created by SyncEngine:

```sql
CREATE TABLE _rhtmx_sync_log (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    entity TEXT NOT NULL,
    entity_id TEXT NOT NULL,
    action TEXT NOT NULL,  -- 'create', 'update', 'delete'
    data TEXT,             -- JSON of entity
    version INTEGER NOT NULL,
    client_id TEXT,        -- For conflict detection
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sync_entity_version ON _rhtmx_sync_log(entity, version);
```

### 2. Auto-Intercepting DB Operations

The `#[derive(Syncable)]` macro wraps database operations:

```rust
// User writes normal code:
pub async fn create_user(pool: &SqlitePool, user: User) -> Result<User> {
    sqlx::query_as!(User, "INSERT INTO users (...) VALUES (...)")
        .execute(pool)
        .await
}

// Macro generates wrapper that:
// 1. Executes the query
// 2. Records change in _rhtmx_sync_log
// 3. Notifies SSE clients
// 4. Returns result
```

### 3. SSE Broadcast

```rust
// In src/sse.rs
pub struct SyncEvent {
    pub entity: String,
    pub action: String,  // "create", "update", "delete"
    pub id: String,
    pub data: Option<serde_json::Value>,
    pub version: i64,
}

impl SseHandler {
    pub async fn broadcast(&self, event: SyncEvent) {
        let message = format!("data: {}\n\n", serde_json::to_string(&event)?);
        for client in self.clients.lock().await.iter() {
            client.send(message.clone()).await;
        }
    }
}
```

### 4. Client-Side IndexedDB Schema

Auto-created by rhtmx-sync.js:

```javascript
{
    stores: {
        users: { keyPath: 'id' },
        posts: { keyPath: 'id' },
        comments: { keyPath: 'id' },
        _meta: { keyPath: 'key' },      // Stores version numbers
        _pending: { autoIncrement: true } // Offline mutation queue
    }
}
```

### 5. Conflict Resolution Strategies

```rust
pub enum SyncStrategy {
    LastWriteWins,      // Default: timestamp-based
    ClientWins,         // Client changes always win
    ServerWins,         // Server changes always win
    Custom(Box<dyn ConflictResolver>),
}

pub trait ConflictResolver: Send + Sync {
    fn resolve<T: Syncable>(&self, server: T, client: T) -> T;
}
```

## API Endpoints

### GET /api/sync/:entity?since=:version
Incremental sync - get changes since version

**Request:**
```
GET /api/sync/users?since=42
```

**Response:**
```json
{
    "entity": "users",
    "version": 45,
    "changes": [
        {
            "id": 1,
            "action": "update",
            "data": { "id": 1, "name": "John", "email": "john@example.com" },
            "version": 43
        },
        {
            "id": 2,
            "action": "delete",
            "version": 44
        }
    ]
}
```

### POST /api/sync/:entity
Push client changes to server

**Request:**
```json
{
    "changes": [
        {
            "id": 3,
            "action": "create",
            "data": { "name": "Alice", "email": "alice@example.com" },
            "client_version": 42
        }
    ]
}
```

**Response:**
```json
{
    "version": 46,
    "conflicts": [],
    "applied": [3]
}
```

### GET /api/sync/events (SSE)
Live event stream

**Stream:**
```
data: {"entity":"users","action":"update","id":1,"version":47}

data: {"entity":"posts","action":"create","id":10,"version":48}
```

### GET /api/sync/client.js
Serves the rhtmx-sync.js client library

## Developer Experience Examples

### Example 1: Basic CRUD with Auto-Sync

```rust
// 1. Define your model (add one derive!)
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow, Syncable)]
pub struct Todo {
    pub id: i32,
    pub title: String,
    pub completed: bool,
}

// 2. Write normal CRUD functions (no changes!)
pub async fn create_todo(pool: &SqlitePool, title: String) -> Result<Todo> {
    sqlx::query_as!(
        Todo,
        "INSERT INTO todos (title, completed) VALUES (?, false) RETURNING *",
        title
    )
    .fetch_one(pool)
    .await
}

// 3. Write normal handlers (no changes!)
get!("todos")
async fn get_todos(ctx: RequestContext) -> OkResponse {
    let todos = get_all_todos(&ctx.db).await?;
    Ok().render(html! {
        <div id="todos">
            @for todo in todos {
                <div class="todo">{ (todo.title) }</div>
            }
        </div>
    })
}

// That's it! Sync happens automatically!
```

### Example 2: Custom Conflict Resolution

```rust
#[derive(Syncable)]
#[sync(strategy = SyncStrategy::Custom)]
pub struct Document {
    pub id: i32,
    pub content: String,
    pub author: String,
}

impl ConflictResolver for DocumentResolver {
    fn resolve(&self, server: Document, client: Document) -> Document {
        // Merge content line by line
        let merged_content = merge_text(&server.content, &client.content);
        Document {
            id: server.id,
            content: merged_content,
            author: format!("{} & {}", server.author, client.author),
        }
    }
}
```

## Dependencies

### rhtmx-sync/Cargo.toml
```toml
[dependencies]
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sqlx = { version = "0.7", features = ["sqlite", "runtime-tokio-rustls", "chrono"] }
chrono = { version = "0.4", features = ["serde"] }
tokio-stream = "0.1"
futures = "0.3"
rhtmx-sync-macro = { path = "./rhtmx-sync-macro" }
```

### rhtmx-sync-macro/Cargo.toml
```toml
[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
```

## Migration Path

For existing RHTMX apps:

1. Add dependency: `rhtmx-sync = { path = "rhtmx-sync" }`
2. Add `#[derive(Syncable)]` to models you want to sync
3. Initialize SyncEngine in main.rs
4. Add script tag to HTML layout
5. Done! No other code changes needed.

## Performance Considerations

- Sync log table grows over time → Add cleanup job (keep last 7 days)
- SSE connections use memory → Limit concurrent connections
- IndexedDB has 50MB default quota → Monitor storage usage
- Large datasets → Implement pagination in sync API
- Network efficiency → Use compression for sync payloads

## Future Enhancements

- [ ] CRDT support (Automerge integration)
- [ ] Partial entity sync (field-level)
- [ ] Sync batching (group multiple changes)
- [ ] WebSocket option (instead of SSE)
- [ ] PostgreSQL support (LISTEN/NOTIFY)
- [ ] Multi-tab sync (BroadcastChannel)
- [ ] Sync progress UI component
